# microservicios_con_spring_boot_y_spring-cloud_netflix_eureka

## Lecciones curso
- Se crea microservicio productos
- Se crea microservicio items.
- Se consulta microservicio productos desde microservicio items con REST TEMPLATE
- Se consulta microservicio productos desde microservicio items con OPEN FEIGN.
- Balanceo de carga con Ribbon con OPEN FEIGN.
- Balanceo de carga con Riboon con RestTemplate.
- Creando servidor eureka y conectando los dos microservicios anteriores al mismo.
- Puerto dinámico para el microservicio de productos.
- Hystrix: tolerancia a fallos: permite enviar el flujo de código a otro sitio cuando se produce un error en el micro de productos.
  - Por defecto, cuando un micro llama a otro, si ese otro tarda en responder más de x tiempo, se produce un error de timeout. Yo lo he probado y no me ha funcionado. Lo que se hace para solventar eso es añadir las properties para ampliar ese timeout de llamada de un microservicio a otro microservicio.
    - hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
    - ribbon.ConnectTimeout: 3000
    - ribbon.ReadTimeout: 10000
- Zuul server: es un servidor para gestionar el api-gateway. 
    - Se implementan filtros pre y post para controlar los eventos de antes y después de lanzar la petición http.
- Spring cloud API Gateway: sustituye a Zuul server para versiones más modernas de springboot. En este caso se utiliza la versión 2.5.3 de springboot, la cual es compatible con la versión 2020.0.3 de spring cloud
  - Filtros pre y post con GlobalFilter y con AbstractGatewayFilterFactory (modificando en ambos casos la request y la response añadiendo headers y cookies).
  - Filtros personalizados de spring que no hace falta programarlos
  - Predicados: condiciones que tienen que cumplir las peticiones para que el cliente las encuentre como tal.
- Resilience: sustituye a hystrix. Si se produce una excepción en un servicio llamado, el error se va propagando a los servicios que lo llaman. Hay un umbral de fallos. 
  - Hay 3 estados:
    - Cerrado: inicial. Si hay x errores, entonces se abre el circuitbreaker.
    - Abierto: se han producido muchos errores y se abre el cortocircuito
    - Semiabierto: se realizan peticiones de un micro a otro para saber si ya está ok.
  - Configuraciones:
    - slidingWindowSize(100): por defecto son 100. De cada cien...se establece un porcentaje falla. Si el porcentaje es mayor que los criterios, se abre el  cortocircuito.
    - failureRateThreshold (50): de cada 100 peticiones, si 50 fallan, se abre el cortocircuito.
    - waitDurationInOpenState (60000 ms): tiempo que permanece el cortocircuito abierto.
    - permittedNumberOfCallsInHalfOpenState(10): hará 10 peticiones de prueba en el caso de que el estado del cortocircuito sea semiabierto.
    - slowCallRateThreshold (100): si de 100 peticiones, las 100 son lentas, se abre el cortocircuito
    - slowCallDurationThreshold (60000 ms): esta propiedad es paara considerar que una llamada es lenta.
  - Con la configuración por defecto lo que hace es:
    - Si hacemos 55 peticiones con error y 45 bien, al completar el ciclo de 100, al ejecutar la 101 pasa por el metodo alternativo (como si estuviese fallando). Esto indica que se ha abierto el cortocircuito 
    - Tras un minuto ya no se trata de 100 peticiones, sino de 10. Si de esas 10 fallan 6, se vuelve a abrir.
    - Y así constantemente.
- Circuit breaker va por un lado y TimeLimitter va por otro (aunque ambos se pueden combinar):
  - Circuit breaker se encarga de gestionar el hecho de que si hay más llamadas erroneas de lo normal, abra el cortocircuito y no permita más llamadas hasta pasado x tiempo
  - Timelimitter: sólo gestiona TimeOut.
-Se puede implementar CircuitBreaker y Timelimitter en el servicio-gateway, para no ir haciéndolo servicio por servicio. Aunque a mi sólo me ha funcionado la parte de timelimitter y no la de circuitbreacker (el fallbackUri no lo hace correctamente).  
- Con la anotación @RepositoryRestResource en el repository, se crea un conjunto de endpoints necesarios para gestionar el CRUD del Dao en el que se ha establecido dicha anotación.
- Config server:
  - Se crea un proyecto nuevo
  - Se indica cuál es la carpeta de configuración donde estarán todos los properties donde cada property tendrá nombre "nombre_instancia.properties".
  - Se definen las configuraciones para cada proyecto
  - Se accede a la ruta http://localhost:8888/servicio-item/default
  - Se establece el servicio item como cliente de este proyecto. Además, la carpeta creada será un repositorio git donde estarán las properties de cada proyecto.
  - Se pueden crear ficheros del tipo servicio-item-dev.properties o servicio-item-prod.properties para luego establecerse en la propiedad spring.profiles.active el perfil (dev o prod)
  - Se pueden modificar properties en tiempo real con @RefreshScope en el controlador, pero hay que inyectar la dependencia en el pom del servicio cuyo controlador es el que se le ha metido la anotación y una vez que modificamos la propiedad, hay que hacer el commit y luego llamar a localhost:8005/actuator/refresh pero la petición tiene que ser de tipo POST. MUY IMPORTANTE.
  - La carpeta config se puede subir a github y habría que modificar la property spring.cloud.config.server.git.uri (que es la que indica dónde está la configuración de nuestro servidor spring) estableciendo https://github.com/nombre_usuario/nombre_repositorio.git
- JWT:
  - Se divide en 3 partes separadas por .: header (algoritmo utilizado y tipo), payload (datos del usuario) y parte de verificación de firma.
  - Con esta instrucción window.atob('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.fwNYPn7BLNzzRTDhEecG6LZ5xkTF8Zj0u8hh_0bzXtk'.split('.')[1]); podemos revertir el payload de un token.
- El API oAuth2 trabaja con JWT
- Para configurar spring security hay que:
  - Crear el repositorio que acceda a la tabla de usuarios
  - Crear un servicio @Service que implemente la interfaz UserDetailsService
  - Registrar en el authentication manager ese servicio a través de la clase SpringSecurityConfig
  - Registrar la configuración en la clase AuthorizationServerConfig () haciendo uso de los 2 beans creados en SpringSecurityConfig:
    - BCryptPasswordEncoder
    - authenticationManager
  - Para lanzar la petición desde postman tenemos que establecer:
    - URL: localhost:8090/api/security/oauth/token (de tipo POST)
    - Pestaña Authorization: 
      - Type: Basic Auth
      - Username: frontendapp (esto se establece en la clase AuthorizationServerConfig (línea en la que se llama al método withClient), que hereda de AuthorizationServerConfigurerAdapter)
      - Password: 12345 (también se establece ahí, en línea que llama al método secret())
    - Body (en radiobutton x-www-form-urlencoded), se añaden pares key-value con las siguientes características:
      - username: nombre del usuario (username se corresponde al atributo username de la clase Usuario).
      - password: contraseña del usuario (password se corresponde al atributo password de la clase Usuario).
      - grant_type: password
- Para refrescar un token (el refreshtoken), hay que hacer una petición a la ruta localhost:8090/api/security/oauth/token pero enviando en el body en el grant type: "refresh_token" y en otro parámetro nuevo llamado "refresh_token" el refresh_token que nos dio la primera petición a este método.
### 18 Notas:
- Desde la versión 2.4 de spring boot en adelante no es compatible con Ribbon.
- Eureka utiliza spring-cloud load balancer
- Por eso en este enfoque se cambia de versión de spring boot y de spring cloud.
- Zuul no es compatible con la versión 2.4 de spring boot y futuras.
- Ribbon utiliza round robbin
- Hystrix sólo es compatible con versiones anteriores a 2.4. A partir de ahí ya se usa Resilience4j
